# single_RIS.sim
# Single RIS Channel Estimation Test
# Author: Wuqiong Zhao
# Date: 2024-01-18

version: 0.3.0
meta:
  title: Single RIS Channel Estimation Test
  author: Wuqiong Zhao
physics:
  frequency: narrow
  off_grid: true
nodes:
  # now both BS and UE are ULA
  - id: BS
    role: receiver
    size: 16 # [16, 4]
    beam: 3 # [4, 2]
    grid: same
    beamforming:
      variable: "W" # combining
  - id: UE
    role: transmitter
    size: 4
    beam: 2
    grid: same
    beamforming:
      variable: "F" # precoding
      scheme: custom # This can be omitted if the formula is specified.
      formula: |
        # Available temporary variables will include SIZE, BEAM, GRID, etc.
        # And the size of W (type 't', i.e. 'c3') is SIZE * BEAM * TIMES
        COMMENT This method is actually the same as that in the sys folder.
        `VAR` = \randn(SIZE, BEAM, TIMES)
        CPP `VAR`.each_slice([](cx_mat& X){return normalise(X,2,0);});
  - id: RIS
    size: [8, 8]
    grid: same
    beamforming:
      variable: "Psi" # RIS reflection pattern
      scheme: custom # This can be omitted if the formula is specified.
      formula: |
        # Available temporary variables will include SIZE, GRID, etc.
        # And the size of Psi (type 'm', i.e. 'c2') is SIZE * TIMES
        # where `TIMES` is the macro (of scope 1 and 2) for the number of phase shift in one sounding.
        Psi = \randn(SIZE, TIMES)
        Psi = Psi / \abs(Psi)
        # Test Macro Here:
        # CAS_CH: `CAS_CH`
        # BF[RIS]: `BF[RIS]`
channels:
  - id: G
    from: RIS
    to: BS
    sparsity: 5
  - id: R
    from: UE
    to: RIS
    sparsity: 3
  # - id: H_direct
  #   from: UE
  #   to: BS
  #   sparsity: 2
sounding:
  variables:
    received: "y"
    noise: "noise"
    channel: "H"
estimation: |
  COMMENT STEP 1: Load Dictionary
  VNt::m = NEW `DICTIONARY.T`
  VNr::m = NEW `DICTIONARY.R`
  D::m   = INIT `GRID[RIS]` `SIZE[RIS]`
  LOOP 0 `SIZE[RIS]`
    tmp::v = \kron(V_M_{i,:}^T, V_M_{i,:}^H)
    D_{:,i} = tmp_{0:`SIZE[RIS]`-1}
  END

  COMMENT STEP 2: Compressed Sensing Formulation
  Q::m = INIT `MEASUREMENT` $`GRID.*` * `GRID[RIS]`$ # sensing matrix
  K = NEW `GRID[RIS]` # number of blocks
  T = NEW `PILOT`/`BEAM.T` # number of sounding times
  k::u0 = LOOP 0 K
    psi::v = NEW Psi_{k} # one reflection vector
    t::u0 = LOOP 0 T
      i::u0 = NEW k * T + t
      F_t::m = NEW F_{:,:,i}
      W_t::m = NEW W_{:,:,i}
      Z_T::m = \kron(F_t^T, W_t^H)
      first_index::u0 = (k * T + t) * `BEAM.*`
      last_index::u0  = first_index + `BEAM.*` - 1
      Q_{first_index:last_index,:} = \kron((D * psi)^T, Z_T @ V_N)
    END
  END

  COMMENT STEP 3: Apply Compressed Sensing Algorithms
  BRANCH
  lambda_hat = ESTIMATE Q y
  MERGE

simulation:
  backend: cpp
  jobs:
  - name: "NMSE v.s. SNR (Pilot: 24)"
    test_num: 200
    SNR: [0:2:30]
    SNR_mode: dB # dB (default) | linear
    pilot: 24
    # pilot_mode: percent # num (default) | percent
    algorithms: # compare different languages
      - alg: OMP
        max_iter: 6
        label: OMP
      - alg: OMPL
        params: "6 1"
        label: OMPL-1
      - alg: OMPL
        params: "6 2"
        label: OMPL-2
      - alg: OMPL
        params: "6 4"
        label: OMPL-4
      - alg: OMPL
        params: "6 8"
        label: OMPL-8
      - alg: Oracle_LS
        label: Oracle LS
  report:
    name: Single_RIS_Simulation
